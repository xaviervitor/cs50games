# Final Project Development Documentation

## First commit - Initial player movement, level blocking and pickup/hold/throw interactions
First, included assets "Starter Assets - First Person Character Controller", the new default unity character controller, to get the basis of a basic first person character controller and "Gridbox Prototype Materials", just for prototyping the level in distinct material colors.

After that, I made the initial level blocking. I'm envisioning a game where you can push, pull, hold and throw heavy objects using a "magnet hand", so I decided to start implementing a basic hold object interaction.

I implemented the "Interaction" button, which allows the player to pick up and drop objects in the "Pickable" physics layer in the level, implemented in the ```PlayerInteract.cs``` script. I had to watch some tutorials, read the new Unity Input System documentation and also read the default ```FirstPersonController.cs``` code as a base to grasp how the new input system works and how to implement a basic button click.

Then, I placed cubes with Rigidbodies to be picked up by the player in the level, and modified the Character Controller's Player Input component Behavior to "Invoke Unity Events" instead of "Send Messages" to have more control of the input phase received. Initially, when I clicked the left mouse button to pickup an object it would pick and throw the object repeatedly about ~20 times per click. I discovered that the reason was the click input was being read as "performed" every frame, and changing this behaviour gave me more control of the phase of the inputs. In the end, that didn't solve the problem fully and I ended up detecting the player input using the variable ```_input.interact```, and storing the value read at the previous frame in the variable ```isLeftMouseDown```, using it to create logic to run the pickup code only once. I decided to keep the Player Input component Behavior in case some other situation requires this control over the input phases.

When the left mouse button is clicked, a Raycast is created to detect objects in the distance of 2 units of the center of the player camera transform. 

As it is, the "First Person Character Controller" made by Unity rotates the *PlayerCameraRoot* - which the *MainCamera* ultimately follows - in the Y axis to make the character look up and down and rotates the Capsule itself in the X axis to look left and right. This is great because it means that if a player model replaces the Capsule it will rotate the same as the camera horizontally. The problem is that because of that logic, neither Capsule rotation nor *PlayerCameraRoot* rotation truly represents the player forward looking direction. This is why I included a empty *PlayerRotationReference* GameObject inside the PlayerCapsule, which is always updated with the current Y rotation of the camera and X rotation of the capsule in the ```CameraRotation()``` function of the ```FirstPersonController.cs``` file. This simplifies code and makes this a Player Rotation Reference accessible for possible future uses.

With that, I now have a character controller, a basic "greybox" level and a pickup/throw interaction.

---

## Second commit - Object distance controls, ground indicator, held object follow with Force, preservation of momentum and crosshair
My first idea for improvement of the player controls was to give the player control of the distance between the camera and the held object, to give more control of where the player can move a magnetic object. Thinking of that, I made the ground indicator, an object that follows the held object and raycasts below it to indicate where the nearest ground the object would fall if it is dropped.

After that, I implemented the distance controls, and wanted to make the held object be more dynamic and react to the physics in a more realistic way. To do that, I had to solve a problem that I avoided in the last commit. Previously, I was just parenting the held object to the player camera rotation object, meaning that the object didn't use any Force to move to its target position, which in turn means that when the object is released, there aren't any forces applied to its Rigidbody.

My idea was to calculate the direction vector that would lead to the target position and move the object along that vector every ```FixedUpdate```, using a force based in the current distance from the target position. This implementation only worked after I changed the Drag property of every held object to 20, in the ```HeldObject.Pickup()```, and made the gameplay finally work the way I intended, now the velocity of the object is preserved when the player releases it.

I had to learn how Rigidbodies behave and the nuances of ```FixedUpdate```, ```Update``` and ```LateUpdate``` to achieve the smooth movement of the held object following the player, as well as the *Ground Indicator* following the held object.

- Added a Crosshair to the center of the HUD and the ```UpdateCrosshairColor.cs``` script, which checks if the PlayerInteract script flagged a object in range for the player to pickup and updates the color of the crosshair accordingly;
- Cleaned up code of the held object, which now lives in the HeldObject class, and the PlayerInteract script now only holds a HoldObject instance when a object is picked up, simplifying the script;
- Downloaded a new shader, "GhostlyHand", from the asset store, which is being used to render the new Held Object Ground Indicator;
- Moved the StarterAssets folder to the Thirdparty folder to be organized in the same folder as the other tools from the asset store.

---

## Third commit - Level almost done, new textures, gamepad control fixes, text tutorial system, magnetic enabling item, player progression storage, breakable glasses, secondary interaction, button and gate programming, fixed objects passing through walls, miscellaneous fixes
Now with the character interaction almost ready and refined in the test level, it is time to make the real Level and refine the controller for the necessities of the final game.

I designed a level that first teaches the controls (movement/mouse look/interact/jump) and introduces the mechanic of picking objects to solve small puzzles. To show the controls to the player, I created the ```ShowTextTutorial.cs``` script that shows and hides text in the canvas coordinating with other instances of the script. If a new trigger is activated and a new message has to be shown, the text is overwritten. To make sure the new text stays at the screen for the correct time, all the "hide" timers first check if the message present in the *Canvas* is the current message before hiding it. The message also is updated when the input method is changed. There are messages for the Mouse/Keyboard input and for the Gamepad input. 

I made a "tower" puzzle, in which the player has to remove objects from its base to pickup the *Magnet Bracelet* item and get to the next room. To make the tower segment I had to put constraints in the X and Z position, X, Y, and Z rotation, in all the interactable objects (all the boxes) and make a script that removes the constraints when the player picks up the object, to get around a limitation of Unity's physics engine regarding stacking objects. Without the constraints, all the objects would interact and the boxes would drift to the sides and fall of the platforms of the puzzle. As I understand, this problem could be solved by increasing the *Default Solver Iterations* option in the project settings, but this would have a high performance cost.

The *Magnetic Bracelet* is just a object that I modeled using the ProBuilder tools, Standard Unity Shader and a Light source, with a simple script that uses Lerp to do some effects (light dimming and platform translation) and changes a variable in the ```PlayerProgression.cs``` static class, that acts like *Singleton* and stores this piece of player progression. My plan is to also use this class to store checkpoints when the player goes through certain areas. 

After the the magnet mechanic is introduced, I made a broken glass wall that breaks when a object with a set speed goes through its collision box. I created the model in blender using a add-on called "Cell Fracture" that creates cuts procedurally, and imported to Unity adding Rigidbodies to all the pieces. Initially they have all the position/rotation constraints set as true and Mass with the value of 1. Then I created a script to react to the trigger collision and attached to the *parent* of every glass in the level. When a rigidbody with a velocity greater than 10 is detected in the box collider of this *parent* GameObject, the constraints of all child objects are removed and the Mass of the glass pieces is set to 0.01 to simulate glass shattering. For the collision effect to work properly, I set the *Collision Detection Mode* to "*Continuous Dynamic*" in the editor. In the ```BreakGlass.cs``` script, after 2 seconds of the impact, I change it to "*Discrete*" for optimization reasons.

The puzzle after the glass shattering segment has boxes inside a strong glass that have to be moved for the stairs leading to the next room to be lowered. This exposed a bug in the character interaction script, in which the player could accelerate the held magnetic object (using ```Q```/```E```) and make it pass through walls. This happened because the pull speed towards the target position is calculated based in distance, which is calculated using the ```playerToObjectDistance``` variable, and I solved the problem creating a Raycast between the "**current object position**" and the "**target position**", detecting walls and, if present, changing the "**target position**" to be the the detected wall hit point and changing the ```playerToObjectDistance``` to be the calculated distance between the player and this new point. That solved the problem for normal walls, but considering that all glass walls were marked as "IgnoreRaycast", the object would pass through those. I had to not use the "IgnoreRaycast" layer anymore and control the layers that get raycasted and those who don't in the Raycast functions. "Glass" is raycasted by the *Wall Raycast* but not raycasted by the *Interact Raycast*, and "BrokenGlass" is not raycasted by any of the raycasts, so that the magnetic object could go through the broken glass and activate the ```BreakGlass.cs``` script.

After the stairs, I made a Button/Gate puzzle, but I wanted the button to feel natural and have some weight. I scraped the button I made in the first commit and designed another using a Rigidbody and applying a Up vector force to be pushed by the weight of the objects and the player, adjusting the force based on how much close it is from the unpressed position. If the button is only pressed by an small amount, 10% for example, the Up force will be only 10% of the ```springForce``` variable. The player doesn't apply its weight by default, so I attached another script, ```PlayerButtonPush.cs```, borrowing some code from ```BasicRigidBodyPush.cs``` script, which comes with the Unity FirstPersonController package, that applies a force to specified layers when a collision is detected. After that I wrote the ```GateButton.cs``` script, that reads a pressed value of a *Button* GameObject and applies a Up force to open the gate/stops applying to close the gate. This script also works for the "reversed" gates.

- Changed the *Default Max Depenetration Velocity* to ```1000``` to prevent objects at high speeds from passing through walls;
- Made a script that slowly changes the Sun direction (rotation) to better frame the first red door, as it is completely in the shadows in the starting sun position, without losing the first room illumination of the Green Ramp and the Blue Cube;
- Created the final Materials, using the Normal Map from the Unity First Person Controller, ```Assets\Thirdparty\StarterAssets\Environment\Art\Textures\Grid_01_Normal.png``` and adding colors based off Gridbox Prototype Materials;
- Changed the code that makes materials transparent when held, to work with textured materials and materials with only flat colors. There are multiple parameters that have to be set to change a material Rendering Mode in scripting, and I found a forum post by the user "berkhulagu" detailing which ones to set;
- Changed the gamepad controls to be more intuitive, adding the secondary input hold objects maintaining their distance from the player as opposed to being attracted immediately;
- Changed the Camera FOV to 80, and tweaked the default ```playerToObjectDistance``` to match;
- Implemented a lower limit to the ```playerToObjectDistance```, as the player should not be able to control the held object behind himself;
- Fixed a bug where if the ground indicator was too close to the ground, it would not detect it and set its size to a big value and not render correctly;
- Made an animation using the Lerp function to turn off the *Magnetic Bracelet* light and move the *Altar* down when the player picks the *Bracelet* up.

---